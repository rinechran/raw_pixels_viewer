<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>RAW Pixels Viewer</title>
<style>
    body {
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        display: flex;
        flex-direction: column;
        min-height: 100vh; /* Full viewport height */
        margin: 0; /* Remove default margin */
        background-color: #f0f0f0; /* Keep or set a background for the page */
        color: #333;
    }
    h1 {
        font-size: 2em;
        margin-bottom: 0.5em;
        text-align: center;
    }
    label, button {
        display: block;
        margin: 10px auto;
        font-size: 1.2em;
    }
    input, select {
        padding: 10px;
        margin-bottom: 15px;
        border-radius: 5px;
        border: none;
        width: calc(100% - 22px);
    }
    button {
        cursor: pointer;
        background: #0063B1;
        color: white;
        border: none;
        padding: 10px 20px;
        border-radius: 5px;
        font-size: 1em;
        transition: background-color 0.3s ease;
    }
    button:hover {
        background: #0052A5;
    }
    canvas {
        background-color: #fff;
        border: 1px solid #ccc;
        box-shadow: 0 0 10px rgba(0,0,0,0.1);
        max-width: calc(100vw - 40px); /* Max width of viewport minus padding */
        max-height: calc(100vh - 350px); /* Approx 350px for footer + pixel info */
        object-fit: contain; /* Scales the image down to fit, maintaining aspect ratio */
    }

    .canvas-wrapper { /* New wrapper for canvas to center it when zoomed */
        display: flex;
        justify-content: center;
        align-items: center;
        flex-grow: 1; /* Allows it to take available vertical space */
        padding: 20px;
        overflow: auto; /* Add scrollbars if canvas (even scaled) is larger than container */
        position: relative; /* Needed for positioning .pixel-info inside it */
        min-height: 150px; /* Minimum height for the canvas area */
    }


    /* Pixel info display */
    .pixel-info {
        background-color: white;
        color: black;
        padding: 8px 12px;
        border-radius: 5px;
        font-family: 'Consolas', monospace;
        font-size: 0.9em;
        position: absolute; /* Position relative to the canvas-wrapper */
        left: 20px; /* Aligns to the left padding of canvas-wrapper */
        top: 20px; /* Aligns to the top padding of canvas-wrapper */
        white-space: nowrap;
        pointer-events: none; /* Allows mouse events to pass through to canvas */
        z-index: 100; /* Ensure it's on top */
        display: none; /* Hidden by default */
        border: 1px solid #ccc; /* Add a subtle border */
    }


    .controls-footer {
        padding: 15px 20px;
        background-color: #333;
        color: white;
        box-shadow: 0 -2px 5px rgba(0,0,0,0.1);
        z-index: 10;
        flex-shrink: 0; /* Prevent footer from shrinking */
    }

    .controls-footer h1, .controls-footer p {
        color: white;
        text-align: center;
        margin-top: 0;
        margin-bottom: 10px;
    }

    .controls-footer label {
        color: #f0f0f0;
        font-size: 1em;
        margin: 0 0 5px 0;
        text-align: left;
        display: block;
    }

    /* Combined container for file input, offset, and BMac button */
    .top-controls-line {
        display: flex;
        flex-wrap: wrap; /* Allows items to wrap on smaller screens */
        align-items: flex-end; /* Aligns items to the bottom of the line */
        gap: 10px; /* Space between input groups */
        margin-bottom: 15px;
    }

    .top-controls-line > div {
        display: flex;
        flex-direction: column;
        flex-grow: 1; /* Allows inputs to take available space */
        min-width: 150px; /* Ensure inputs don't become too small */
    }
    /* Specific width adjustment for file input to allow more room for offset/zoom */
    .top-controls-line > div:nth-child(1) { /* File input wrapper */
        flex-basis: 30%; /* Give file input a bit more room */
    }
    .top-controls-line > div:nth-child(2), /* Offset input wrapper */
    .top-controls-line > div:nth-child(3) { /* Zoom input wrapper */
        flex-basis: 20%; /* Give offset and zoom inputs a bit more room, or equally distribute */
    }


    .top-controls-line input[type="file"],
    .top-controls-line input[type="number"] {
        width: 100%;
        box-sizing: border-box;
        margin-bottom: 0; /* Remove extra margin below input */
    }

    /* Style for Buy Me a Coffee button wrapper */
    .bmac-button-wrapper {
        text-align: right;
        flex-shrink: 0; /* Prevents shrinking */
        padding-top: 25px; /* Adjust to align with input baselines */
        min-width: 162px; /* Fixed width for the button image */
    }

    .controls-horizontal-line {
        display: flex;
        flex-wrap: wrap;
        justify-content: space-between;
        align-items: flex-start;
        gap: 10px;
    }

    .controls-horizontal-line > div {
        display: flex;
        flex-direction: column;
        flex-basis: calc(25% - 10px);
        min-width: 120px;
        box-sizing: border-box;
    }
    /* Removed specific flex-basis for zoom input as it's moved */

    .controls-horizontal-line input,
    .controls-horizontal-line select {
        width: 100%;
        box-sizing: border-box;
        padding: 10px;
        margin-bottom: 0;
        color: #333;
        background-color: #fff;
    }

    @media (max-width: 768px) {
        .controls-footer {
            padding: 10px;
        }
        .top-controls-line {
            flex-direction: column; /* Stack vertically on small screens */
            align-items: stretch;
        }
        .top-controls-line > div {
            margin-bottom: 10px; /* Add space between stacked items */
        }
        .top-controls-line > div:last-child {
            margin-bottom: 0;
        }
        /* Specific widths for file, offset, zoom should revert to full width on small screens */
        .top-controls-line > div:nth-child(1),
        .top-controls-line > div:nth-child(2),
        .top-controls-line > div:nth-child(3) {
            flex-basis: 100%;
        }

        .bmac-button-wrapper {
            text-align: center;
            padding-top: 0;
            margin-top: 10px; /* Space from input above it */
            min-width: unset; /* Remove fixed width on small screens */
        }
        .controls-horizontal-line {
            flex-direction: column;
            gap: 0;
        }
        .controls-horizontal-line > div {
            flex-basis: 100%;
            margin-bottom: 10px;
        }
        .controls-horizontal-line > div:last-child {
            margin-bottom: 0;
        }
        .pixel-info {
            font-size: 0.8em;
            padding: 6px 10px;
            top: 10px; /* Adjust position for small screens */
            left: 10px;
        }
    }
</style>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-T52592T23E"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-T52592T23E');
</script>
</head>
<body>

    <div class="canvas-wrapper">
        <div class="pixel-info" id="pixelInfo"></div>
        <canvas id="canvas"></canvas>
    </div>

    <footer class="controls-footer">
        <h1>RAW Pixels Viewer</h1>

        <div class="top-controls-line">
            <div>
                <label for="fileInput">Select Image File:</label>
                <input type="file" id="fileInput"/>
            </div>
            <div>
                <label for="offsetInput">Offset (bytes):</label>
                <input type="number" id="offsetInput" value="0" min="0" placeholder="Start offset in bytes"/>
            </div>
            <div> <label for="zoomInput">Zoom (%):</label>
                <input type="number" id="zoomInput" value="100" min="10" max="800" step="10"/>
            </div>
            <div class="bmac-button-wrapper">
                <a href="https://www.buymeacoffee.com/rinechran" target="_blank">
                    <img src="https://cdn.buymeacoffee.com/buttons/v2/default-yellow.png" alt="Buy Me a Coffee" style="height: 45px; width: 162px;" >
                </a>
            </div>
        </div>

        <div class="controls-horizontal-line">
            <div>
                <label for="formatSelect">Select Format:</label>
                <select id="formatSelect">
                    <option value="RGB">RGB888 (24bit)</option>
                    <option value="BGR">BGR888 (24bit)</option>
                    <option value="GBR">GBR888 (24bit)</option>
                    <option value="RGBA">RGBA32 (32bit)</option>
                    <option value="BGRA">BGRA32 (32bit)</option>
                    <option value="ARGB32">ARGB32 (32bit)</option>
                    <option value="ABGR32">ABGR32 (32bit)</option>
                    <option value="XRGB8888">XRGB8888 (32bit, X ignored)</option>
                    <option value="RGB565">RGB565 (16bit)</option>
                    <option value="BGR565">BGR565 (16bit)</option>
                    <option value="RGB555">RGB555 (16bit - XRGB1555)</option>
                    <option value="RGBA4444">RGBA4444 (16bit)</option>
                    <option value="ARGB1555">ARGB1555 (16bit)</option>
                    <option value="Grayscale">Grayscale (8bit)</option>
                    <option value="YUV420p">YUV420p (Planar)</option>
                    <option value="YUV422p">YUV422p (Planar)</option>
                    <option value="YUV444p">YUV444p (Planar)</option>
                    <option value="NV12">NV12 (Semi-Planar Y + UV)</option>
                    <option value="NV21">NV21 (Semi-Planar Y + VU)</option>
                    <option value="YUYV">YUYV (Packed 4:2:2)</option>
                    <option value="YVYU">YVYU (Packed 4:2:2)</option>
                </select>
            </div>
            <div>
                <label for="widthInput">Width:</label>
                <input type="number" id="widthInput" placeholder="Enter width"/>
            </div>
            <div>
                <label for="heightInput">Height:</label>
                <input type="number" id="heightInput" placeholder="Enter height"/>
            </div>
            <div>
                <label for="strideInput">Stride (bytes, optional):</label>
                <input type="number" id="strideInput" placeholder="e.g., width * bpp"/>
            </div>
            </div>
    </footer>

    <script>
        // State variables to hold the currently displayed image's data and parameters
        let currentImageBuffer = null;
        let currentImageWidth = 0;
        let currentImageHeight = 0;
        let currentImageFormat = '';
        let currentImageStride = 0; // Initialize stride
        let currentImageOffset = 0; // Initialize offset
        let currentZoomLevel = 100; // Initialize zoom level

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const fileInput = document.getElementById('fileInput');
        const widthInput = document.getElementById('widthInput');
        const heightInput = document.getElementById('heightInput');
        const formatSelect = document.getElementById('formatSelect');
        const strideInput = document.getElementById('strideInput');
        const offsetInput = document.getElementById('offsetInput');
        const zoomInput = document.getElementById('zoomInput'); // Get zoom input
        const pixelInfo = document.getElementById('pixelInfo');

        /**
         * Loads a default YUV420p image from 'resource/yuv420p.yuv' and displays it.
         * Sets the UI controls to match the default image's parameters.
         */
        async function loadDefaultYUV() {
            // Set default values for the UI controls
            widthInput.value = '512';
            heightInput.value = '512';
            formatSelect.value = 'YUV420p';
            strideInput.value = ''; // Clear stride for default YUV as it's typically derived
            offsetInput.value = '0'; // Set default offset to 0
            zoomInput.value = '100'; // Set default zoom to 100%

            try {
                const response = await fetch('resource/yuv420p.yuv');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}, message: ${response.statusText || 'Unknown error'}. Make sure 'resource/yuv420p.yuv' exists.`);
                }
                const arrayBuffer = await response.arrayBuffer();
                const rawDataUint8Array = new Uint8Array(arrayBuffer);

                // Update state variables for the default image
                currentImageBuffer = rawDataUint8Array;
                currentImageWidth = 512;
                currentImageHeight = 512;
                currentImageFormat = 'YUV420p';
                currentImageStride = 0; // For planar formats, stride is effectively 0 or derived internally
                currentImageOffset = 0; // Set default offset to 0
                currentZoomLevel = 100; // Set default zoom

                // Call displayImage to render the default image
                displayImage();

            } catch (error) {
                console.error('Failed to load or process default YUV file:', error);

                // Clear canvas and display error message
                // The canvas width/height are now controlled by displayImage and CSS.
                // We ensure minimal size for the message.
                canvas.width = 300;
                canvas.height = 150;
                canvas.style.width = '300px'; // Set CSS width
                canvas.style.height = '150px'; // Set CSS height
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = 'red';
                ctx.font = '16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Failed to load default YUV.', canvas.width / 2, canvas.height / 2 - 10);
                ctx.fillText(error.message, canvas.width / 2, canvas.height / 2 + 10);
                currentImageBuffer = null; // Clear buffer if default load fails
            }
        }

        /**
         * Processes the raw image data based on the selected format, width, height, and stride,
         * and renders it onto the canvas.
         * @param {Uint8Array} rawDataUint8Array - The raw image data as a Uint8Array.
         * @param {number} width - The width of the image.
         * @param {number} height - The height of the image.
         * @param {string} format - The pixel format (e.g., 'RGB', 'YUV420p').
         * @param {number} [stride=0] - Optional: The stride in bytes per row. If 0 or not provided, calculated.
         * @param {number} [offset=0] - Optional: The byte offset to start reading from.
         * @param {number} [zoom=100] - Optional: Zoom level in percentage.
         */
        function processImageData(rawDataUint8Array, width, height, format, stride = 0, offset = 0, zoom = 100) {
            const displayWidth = Math.max(1, parseInt(width, 10));
            const displayHeight = Math.max(1, parseInt(height, 10));

            // Set canvas intrinsic dimensions (actual pixel resolution)
            canvas.width = displayWidth;
            canvas.height = displayHeight;

            // Set canvas display dimensions (CSS pixels) based on zoom level
            canvas.style.width = `${displayWidth * (zoom / 100)}px`;
            canvas.style.height = `${displayHeight * (zoom / 100)}px`;

            ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear before drawing

            if (!rawDataUint8Array || rawDataUint8Array.length === 0 || isNaN(displayWidth) || isNaN(displayHeight)) {
                ctx.fillStyle = 'gray';
                ctx.font = '16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('No image data or invalid dimensions.', canvas.width / 2, canvas.height / 2);
                return;
            }

            let bytesPerPixel;
            switch(format) {
                case 'RGB': case 'BGR': case 'GBR':
                    bytesPerPixel = 3;
                    break;
                case 'RGBA': case 'BGRA': case 'ARGB32': case 'ABGR32': case 'XRGB8888':
                    bytesPerPixel = 4;
                    break;
                case 'RGB565': case 'BGR565': case 'RGBA4444': case 'ARGB1555': case 'RGB555':
                    bytesPerPixel = 2;
                    break;
                case 'Grayscale':
                    bytesPerPixel = 1;
                    break;
                case 'YUV420p': case 'NV12': case 'NV21':
                    bytesPerPixel = 1.5; // Effective average BPP
                    break;
                case 'YUV422p': case 'YUYV': case 'YVYU':
                    bytesPerPixel = 2; // Effective average BPP
                    break;
                case 'YUV444p':
                    bytesPerPixel = 3; // Effective average BPP
                    break;
                default:
                    console.error("Unsupported format: " + format);
                    ctx.fillStyle = 'red';
                    ctx.font = '16px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('Unsupported format.', canvas.width / 2, canvas.height / 2);
                    return;
            }

            let effectiveStride = stride;
            if ((format.includes('RGB') || format.includes('GRA') || format === 'Grayscale' || format.includes('565') || format.includes('555') || format.includes('4444') || format.includes('1555')) && (isNaN(effectiveStride) || effectiveStride < displayWidth * bytesPerPixel)) {
                effectiveStride = displayWidth * bytesPerPixel;
                if (!isNaN(stride) && stride < displayWidth * bytesPerPixel) {
                    console.warn(`User stride ${stride} is less than calculated default stride ${displayWidth * bytesPerPixel} for format ${format}. Using default stride.`);
                }
            } else if (format === 'YUYV' || format === 'YVYU') {
                effectiveStride = displayWidth * 2;
                if (!isNaN(stride) && stride >= displayWidth * 2) {
                     effectiveStride = stride;
                } else if (!isNaN(stride) && stride < displayWidth * 2) {
                    console.warn(`User stride ${stride} is less than calculated default stride ${displayWidth * 2} for format ${format}. Using default stride.`);
                }
            }

            const dataToProcess = rawDataUint8Array.subarray(offset);

            let yPlane, uPlane, vPlane, uvPlane;
            const yPlaneSize = displayWidth * displayHeight;
            let currentOffsetInSubarray = 0;

            try {
                if (format.startsWith('YUV') && format.endsWith('p') || format.startsWith('NV')) {
                    if (dataToProcess.length < currentOffsetInSubarray + yPlaneSize) {
                        console.warn(`Not enough data for Y plane for ${format}. Data length: ${dataToProcess.length}, required: ${currentOffsetInSubarray + yPlaneSize}`);
                    }
                    yPlane = dataToProcess.subarray(currentOffsetInSubarray, currentOffsetInSubarray + yPlaneSize);
                    currentOffsetInSubarray += yPlaneSize;

                    if (format === 'YUV444p') {
                        if (dataToProcess.length < currentOffsetInSubarray + yPlaneSize * 2) {
                            console.warn(`Not enough data for U/V planes for ${format}. Data length: ${dataToProcess.length}, required: ${currentOffsetInSubarray + yPlaneSize * 2}`);
                        }
                        uPlane = dataToProcess.subarray(currentOffsetInSubarray, currentOffsetInSubarray + yPlaneSize);
                        currentOffsetInSubarray += yPlaneSize;
                        vPlane = dataToProcess.subarray(currentOffsetInSubarray, currentOffsetInSubarray + yPlaneSize);
                    } else if (format === 'YUV422p') {
                        const chromaWidth = Math.floor(displayWidth / 2);
                        if (dataToProcess.length < currentOffsetInSubarray + chromaWidth * displayHeight * 2) {
                             console.warn(`Not enough data for U/V planes for ${format}. Data length: ${dataToProcess.length}, required: ${currentOffsetInSubarray + chromaWidth * displayHeight * 2}`);
                        }
                        uPlane = dataToProcess.subarray(currentOffsetInSubarray, currentOffsetInSubarray + chromaWidth * displayHeight);
                        currentOffsetInSubarray += chromaWidth * displayHeight;
                        vPlane = dataToProcess.subarray(currentOffsetInSubarray, currentOffsetInSubarray + chromaWidth * displayHeight);
                    } else if (format === 'YUV420p') {
                        const chromaWidth = Math.floor(displayWidth / 2);
                        const chromaHeight = Math.floor(displayHeight / 2);
                        if (dataToProcess.length < currentOffsetInSubarray + chromaWidth * chromaHeight * 2) {
                            console.warn(`Not enough data for U/V planes for ${format}. Data length: ${dataToProcess.length}, required: ${currentOffsetInSubarray + chromaWidth * chromaHeight * 2}`);
                        }
                        uPlane = dataToProcess.subarray(currentOffsetInSubarray, currentOffsetInSubarray + chromaWidth * chromaHeight);
                        currentOffsetInSubarray += chromaWidth * chromaHeight;
                        vPlane = dataToProcess.subarray(currentOffsetInSubarray, currentOffsetInSubarray + chromaWidth * chromaHeight);
                    } else if (format === 'NV12' || format === 'NV21') {
                        if (dataToProcess.length < currentOffsetInSubarray + displayWidth * Math.floor(displayHeight / 2)) {
                            console.warn(`Not enough data for UV plane for ${format}. Data length: ${dataToProcess.length}, required: ${currentOffsetInSubarray + displayWidth * Math.floor(displayHeight / 2)}`);
                        }
                        uvPlane = dataToProcess.subarray(currentOffsetInSubarray, currentOffsetInSubarray + displayWidth * Math.floor(displayHeight / 2));
                    }
                }
            } catch (error) {
                console.error(`Error initializing YUV planes for ${format}: ${error.message}`);
            }

            const imageData = ctx.createImageData(displayWidth, displayHeight);
            const data = imageData.data;

            for (let r = 0; r < displayHeight; r++) {
                for (let c = 0; c < displayWidth; c++) {
                    const canvasPixelIndex = (r * displayWidth + c) * 4;
                    let R = 0, G = 0, B = 0, A = 255;

                    let rawDataOffsetRelative = 0;
                    if (!(format.startsWith('YUV') && format.endsWith('p') || format.startsWith('NV'))) {
                        rawDataOffsetRelative = r * effectiveStride + c * bytesPerPixel;
                        if (rawDataOffsetRelative + bytesPerPixel > dataToProcess.length) {
                            data[canvasPixelIndex] = 0;
                            data[canvasPixelIndex + 1] = 0;
                            data[canvasPixelIndex + 2] = 0;
                            data[canvasPixelIndex + 3] = 255;
                            continue;
                        }
                    }

                    switch (format) {
                        case 'RGB':
                            R = dataToProcess[rawDataOffsetRelative];
                            G = dataToProcess[rawDataOffsetRelative + 1];
                            B = dataToProcess[rawDataOffsetRelative + 2];
                            break;
                        case 'BGR':
                            B = dataToProcess[rawDataOffsetRelative];
                            G = dataToProcess[rawDataOffsetRelative + 1];
                            R = dataToProcess[rawDataOffsetRelative + 2];
                            break;
                        case 'GBR':
                            G = dataToProcess[rawDataOffsetRelative];
                            B = dataToProcess[rawDataOffsetRelative + 1];
                            R = dataToProcess[rawDataOffsetRelative + 2];
                            break;
                        case 'RGBA':
                            R = dataToProcess[rawDataOffsetRelative];
                            G = dataToProcess[rawDataOffsetRelative + 1];
                            B = dataToProcess[rawDataOffsetRelative + 2];
                            A = dataToProcess[rawDataOffsetRelative + 3];
                            break;
                        case 'BGRA':
                            B = dataToProcess[rawDataOffsetRelative];
                            G = dataToProcess[rawDataOffsetRelative + 1];
                            R = dataToProcess[rawDataOffsetRelative + 2];
                            A = dataToProcess[rawDataOffsetRelative + 3];
                            break;
                        case 'ARGB32':
                            A = dataToProcess[rawDataOffsetRelative];
                            R = dataToProcess[rawDataOffsetRelative + 1];
                            G = dataToProcess[rawDataOffsetRelative + 2];
                            B = dataToProcess[rawDataOffsetRelative + 3];
                            break;
                        case 'ABGR32':
                            A = dataToProcess[rawDataOffsetRelative];
                            B = dataToProcess[rawDataOffsetRelative + 1];
                            G = dataToProcess[rawDataOffsetRelative + 2];
                            R = dataToProcess[rawDataOffsetRelative + 3];
                            break;
                        case 'XRGB8888':
                            R = dataToProcess[rawDataOffsetRelative + 1];
                            G = dataToProcess[rawDataOffsetRelative + 2];
                            B = dataToProcess[rawDataOffsetRelative + 3];
                            break;
                        case 'Grayscale':
                            R = G = B = dataToProcess[rawDataOffsetRelative];
                            break;
                        case 'RGB565': {
                            if (rawDataOffsetRelative + 1 >= dataToProcess.length) continue;
                            const w = dataToProcess[rawDataOffsetRelative] | (dataToProcess[rawDataOffsetRelative + 1] << 8);
                            R = ((w >> 11) & 0x1F) * 255 / 31;
                            G = ((w >> 5) & 0x3F) * 255 / 63;
                            B = (w & 0x1F) * 255 / 31;
                            break;
                        }
                        case 'BGR565': {
                            if (rawDataOffsetRelative + 1 >= dataToProcess.length) continue;
                            const w = dataToProcess[rawDataOffsetRelative] | (dataToProcess[rawDataOffsetRelative + 1] << 8);
                            B = ((w >> 11) & 0x1F) * 255 / 31;
                            G = ((w >> 5) & 0x3F) * 255 / 63;
                            R = (w & 0x1F) * 255 / 31;
                            break;
                        }
                        case 'RGB555': {
                            if (rawDataOffsetRelative + 1 >= dataToProcess.length) continue;
                            const w = dataToProcess[rawDataOffsetRelative] | (dataToProcess[rawDataOffsetRelative + 1] << 8);
                            R = ((w >> 10) & 0x1F) * 255 / 31;
                            G = ((w >> 5) & 0x1F) * 255 / 31;
                            B = (w & 0x1F) * 255 / 31;
                            break;
                        }
                        case 'RGBA4444': {
                            if (rawDataOffsetRelative + 1 >= dataToProcess.length) continue;
                            const w = dataToProcess[rawDataOffsetRelative] | (dataToProcess[rawDataOffsetRelative + 1] << 8);
                            R = (w & 0xF) * 255 / 15;
                            G = ((w >> 4) & 0xF) * 255 / 15;
                            B = ((w >> 8) & 0xF) * 255 / 15;
                            A = ((w >> 12) & 0xF) * 255 / 15;
                            break;
                        }
                        case 'ARGB1555': {
                            if (rawDataOffsetRelative + 1 >= dataToProcess.length) continue;
                            const w = dataToProcess[rawDataOffsetRelative] | (dataToProcess[rawDataOffsetRelative + 1] << 8);
                            A = ((w >> 15) & 1) * 255;
                            R = ((w >> 10) & 0x1F) * 255 / 31;
                            G = ((w >> 5) & 0x1F) * 255 / 31;
                            B = (w & 0x1F) * 255 / 31;
                            break;
                        }
                        case 'YUV444p': {
                            if (!yPlane || !uPlane || !vPlane || yPlane.length <= (r * displayWidth + c) || uPlane.length <= (r * displayWidth + c) || vPlane.length <= (r * displayWidth + c)) continue;
                            const yI = r * displayWidth + c;
                            const Yv = yPlane[yI];
                            const Uv = uPlane[yI] - 128;
                            const Vv = vPlane[yI] - 128;
                            R = Yv + 1.402 * Vv;
                            G = Yv - 0.344136 * Uv - 0.714136 * Vv;
                            B = Yv + 1.772 * Uv;
                            break;
                        }
                        case 'YUV422p': {
                            if (!yPlane || !uPlane || !vPlane) continue;
                            const yI = r * displayWidth + c;
                            const cX = Math.floor(c / 2);
                            const uI = r * Math.floor(displayWidth / 2) + cX;
                            if (yPlane.length <= yI || uPlane.length <= uI || vPlane.length <= uI) continue;

                            const Yv = yPlane[yI];
                            const Uv = uPlane[uI] - 128;
                            const Vv = vPlane[uI] - 128;
                            R = Yv + 1.402 * Vv;
                            G = Yv - 0.344136 * Uv - 0.714136 * Vv;
                            B = Yv + 1.772 * Uv;
                            break;
                        }
                        case 'YUV420p': {
                            if (!yPlane || !uPlane || !vPlane) continue;
                            const yI = r * displayWidth + c;
                            const cX = Math.floor(c / 2);
                            const cY = Math.floor(r / 2);
                            const uI = cY * Math.floor(displayWidth / 2) + cX;
                            if (yPlane.length <= yI || uPlane.length <= uI || vPlane.length <= uI) continue;

                            const Yv = yPlane[yI];
                            const Uv = uPlane[uI] - 128;
                            const Vv = vPlane[uI] - 128;
                            R = Yv + 1.402 * Vv;
                            G = Yv - 0.344136 * Uv - 0.714136 * Vv;
                            B = Yv + 1.772 * Uv;
                            break;
                        }
                        case 'NV12': {
                            if (!yPlane || !uvPlane) continue;
                            const yI = r * displayWidth + c;
                            const cX = Math.floor(c / 2);
                            const cY = Math.floor(r / 2);
                            const uvI = cY * displayWidth + cX * 2;
                            if (yPlane.length <= yI || uvPlane.length <= uvI + 1) continue;

                            const Yv = yPlane[yI];
                            const Uv = uvPlane[uvI] - 128;
                            const Vv = uvPlane[uvI + 1] - 128;
                            R = Yv + 1.402 * Vv;
                            G = Yv - 0.344136 * Uv - 0.714136 * Vv;
                            B = Yv + 1.772 * Uv;
                            break;
                        }
                        case 'NV21': {
                            if (!yPlane || !uvPlane) continue;
                            const yI = r * displayWidth + c;
                            const cX = Math.floor(c / 2);
                            const cY = Math.floor(r / 2);
                            const vuI = cY * displayWidth + cX * 2;
                            if (yPlane.length <= yI || uvPlane.length <= vuI + 1) continue;

                            const Yv = yPlane[yI];
                            const Vv = uvPlane[vuI] - 128;
                            const Uv = uvPlane[vuI + 1] - 128;
                            R = Yv + 1.402 * Vv;
                            G = Yv - 0.344136 * Uv - 0.714136 * Vv;
                            B = Yv + 1.772 * Uv;
                            break;
                        }
                        case 'YUYV': {
                            const rawDataOffsetRelative = r * effectiveStride + Math.floor(c / 2) * 4;
                            if (rawDataOffsetRelative + 3 >= dataToProcess.length) continue;

                            let Yv, Uv, Vv;
                            if (c % 2 === 0) {
                                Yv = dataToProcess[rawDataOffsetRelative];
                                Uv = dataToProcess[rawDataOffsetRelative + 1] - 128;
                                Vv = dataToProcess[rawDataOffsetRelative + 3] - 128;
                            } else {
                                Yv = dataToProcess[rawDataOffsetRelative + 2];
                                Uv = dataToProcess[rawDataOffsetRelative + 1] - 128;
                                Vv = dataToProcess[rawDataOffsetRelative + 3] - 128;
                            }
                            R = Yv + 1.402 * Vv;
                            G = Yv - 0.344136 * Uv - 0.714136 * Vv;
                            B = Yv + 1.772 * Uv;
                            break;
                        }
                        case 'YVYU': {
                            const rawDataOffsetRelative = r * effectiveStride + Math.floor(c / 2) * 4;
                            if (rawDataOffsetRelative + 3 >= dataToProcess.length) continue;

                            let Yv, Uv, Vv;
                            if (c % 2 === 0) {
                                Yv = dataToProcess[rawDataOffsetRelative];
                                Vv = dataToProcess[rawDataOffsetRelative + 1] - 128;
                                Uv = dataToProcess[rawDataOffsetRelative + 3] - 128;
                            } else {
                                Yv = dataToProcess[rawDataOffsetRelative + 2];
                                Vv = dataToProcess[rawDataOffsetRelative + 1] - 128;
                                Uv = dataToProcess[rawDataOffsetRelative + 3] - 128;
                            }
                            R = Yv + 1.402 * Vv;
                            G = Yv - 0.344136 * Uv - 0.714136 * Vv;
                            B = Yv + 1.772 * Uv;
                            break;
                        }
                        default:
                            console.error("Unhandled format in pixel loop:", format);
                            data[canvasPixelIndex] = 0;
                            data[canvasPixelIndex + 1] = 0;
                            data[canvasPixelIndex + 2] = 0;
                            data[canvasPixelIndex + 3] = 255;
                            continue;
                    }

                    data[canvasPixelIndex] = Math.max(0, Math.min(255, R));
                    data[canvasPixelIndex + 1] = Math.max(0, Math.min(255, G));
                    data[canvasPixelIndex + 2] = Math.max(0, Math.min(255, B));
                    data[canvasPixelIndex + 3] = Math.max(0, Math.min(255, A));
                }
            }
            ctx.putImageData(imageData, 0, 0);
        }

        /**
         * Orchestrates the display of an image, either from a new file input or by reprocessing
         * the currently loaded image data with updated parameters from the UI.
         */
        function displayImage() {
            const width = parseInt(widthInput.value, 10);
            const height = parseInt(heightInput.value, 10);
            const format = formatSelect.value;
            const stride = parseInt(strideInput.value, 10);
            const offset = parseInt(offsetInput.value, 10);
            const zoom = parseInt(zoomInput.value, 10);

            if (isNaN(offset) || offset < 0) {
                 console.warn("Invalid offset entered. Defaulting to 0.");
                 offsetInput.value = '0';
                 currentImageOffset = 0;
                 if (currentImageBuffer) {
                    processImageData(currentImageBuffer, width, height, format, stride, 0, zoom);
                 } else {
                    canvas.width = 300; canvas.height = 150;
                    canvas.style.width = '300px'; canvas.style.height = '150px';
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = 'gray';
                    ctx.font = '16px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('Please select an image file.', canvas.width / 2, canvas.height / 2);
                 }
                 return;
            }
            currentImageOffset = offset;

            // Validate zoom level
            const effectiveZoom = isNaN(zoom) || zoom < 10 || zoom > 800 ? 100 : zoom;
            if (isNaN(zoom) || zoom < 10 || zoom > 800) {
                console.warn(`Invalid zoom level (${zoom}) entered. Defaulting to 100%.`);
                zoomInput.value = '100';
            }
            currentZoomLevel = effectiveZoom;

            const effectiveWidth = isNaN(width) || width <= 0 ? 1 : width;
            const effectiveHeight = isNaN(height) || height <= 0 ? 1 : height;

            if (isNaN(width) || width <= 0 || isNaN(height) || height <= 0) {
                console.warn(`Invalid width (${width}) or height (${height}) entered. Using ${effectiveWidth}x${effectiveHeight} for display.`);
            }

            if (fileInput.files.length > 0) {
                const file = fileInput.files[0];
                const reader = new FileReader();

                reader.onload = function(e) {
                    const newBuffer = new Uint8Array(e.target.result);
                    currentImageBuffer = newBuffer;
                    currentImageWidth = effectiveWidth;
                    currentImageHeight = effectiveHeight;
                    currentImageFormat = format;
                    currentImageStride = isNaN(stride) ? 0 : stride;

                    processImageData(currentImageBuffer, currentImageWidth, currentImageHeight, currentImageFormat, currentImageStride, currentImageOffset, currentZoomLevel);
                };

                reader.onerror = function() {
                    console.error('Error reading file. Please check the file and permissions.');
                    canvas.width = 300; canvas.height = 150;
                    canvas.style.width = '300px'; canvas.style.height = '150px';
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = 'red';
                    ctx.font = '16px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('Error reading file.', canvas.width / 2, canvas.height / 2);
                    currentImageBuffer = null;
                };
                reader.readAsArrayBuffer(file);
            } else if (currentImageBuffer) {
                currentImageWidth = effectiveWidth;
                currentImageHeight = effectiveHeight;
                currentImageFormat = format;
                currentImageStride = isNaN(stride) ? 0 : stride;

                processImageData(currentImageBuffer, currentImageWidth, currentImageHeight, currentImageFormat, currentImageStride, currentImageOffset, currentZoomLevel);
            } else {
                canvas.width = 300; canvas.height = 150;
                canvas.style.width = '300px'; canvas.style.height = '150px';
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = 'gray';
                ctx.font = '16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Please select an image file.', canvas.width / 2, canvas.height / 2);
            }
        }

        // --- Mouse Event Handlers ---
        canvas.addEventListener('mousemove', function(e) {
            if (!currentImageBuffer || canvas.width <= 0 || canvas.height <= 0) {
                pixelInfo.style.display = 'none';
                return;
            }

            const rect = canvas.getBoundingClientRect();
            const displayedWidth = rect.width;
            const displayedHeight = rect.height;

            const scaleX = canvas.width / displayedWidth;
            const scaleY = canvas.height / displayedHeight;

            const x = Math.floor((e.clientX - rect.left) * scaleX);
            const y = Math.floor((e.clientY - rect.top) * scaleY);

            if (x >= 0 && x < canvas.width && y >= 0 && y < canvas.height) {
                const pixel = ctx.getImageData(x, y, 1, 1).data;
                const r = pixel[0];
                const g = pixel[1];
                const b = pixel[2];
                const a = pixel[3];

                pixelInfo.textContent = `X: ${x}, Y: ${y} | RGB: (${r}, ${g}, ${b})${a !== 255 ? `, A: ${a}` : ''}`;
                pixelInfo.style.display = 'block';

            } else {
                pixelInfo.style.display = 'none';
            }
        });

        canvas.addEventListener('mouseout', function() {
            pixelInfo.style.display = 'none';
        });

        // --- Event Listeners ---
        fileInput.addEventListener('change', () => {
            widthInput.value = '';
            heightInput.value = '';
            strideInput.value = '';
            offsetInput.value = '0';
            zoomInput.value = '100'; // Reset zoom on new file
            displayImage();
        });

        formatSelect.addEventListener('change', displayImage);
        widthInput.addEventListener('input', displayImage);
        heightInput.addEventListener('input', displayImage);
        strideInput.addEventListener('input', displayImage);
        offsetInput.addEventListener('input', displayImage);
        zoomInput.addEventListener('input', displayImage); // Listen for zoom changes

        // Load default YUV image when the DOM is fully loaded
        window.addEventListener('DOMContentLoaded', loadDefaultYUV);
    </script>
</body>
</html>